/**
 * Extension Creator — Template-based self-extension
 *
 * Creates simple pi extensions from templates. Guardrails:
 * - Template-based only (no arbitrary code gen)
 * - Written to ~/.pi/agent/extensions/ with auto-* prefix
 * - Limited to: tool registration, simple hooks, commands
 * - NOT allowed: tool_call interception, session_shutdown, bash execution
 * - Includes AUTO-GENERATED header for review awareness
 */

import { writeFile, mkdir } from "node:fs/promises";
import { existsSync } from "node:fs";
import { join } from "node:path";
import { homedir } from "node:os";

// ── Paths ──────────────────────────────────────────────────────────────────

const EXTENSIONS_DIR = join(homedir(), ".pi", "agent", "extensions");

// ── Types ──────────────────────────────────────────────────────────────────

export type ExtensionTemplate = "tool" | "context-injector" | "command" | "event-logger";

export interface CreateExtensionParams {
	name: string;
	template: ExtensionTemplate;
	description: string;
	/** Template-specific config */
	config: ToolConfig | ContextInjectorConfig | CommandConfig | EventLoggerConfig;
}

export interface ToolConfig {
	toolName: string;
	toolDescription: string;
	parameters: Array<{ name: string; type: "string" | "number" | "boolean"; description: string; required?: boolean }>;
	/** The tool's execute body — what it should do (plain description, will be wrapped) */
	executeLogic: string;
}

export interface ContextInjectorConfig {
	/** What to inject into the system prompt */
	contextContent: string;
	/** When to inject — always or condition description */
	condition?: string;
}

export interface CommandConfig {
	commandName: string;
	commandDescription: string;
	/** What the command does (plain description) */
	handlerLogic: string;
}

export interface EventLoggerConfig {
	/** Which events to log */
	events: string[];
	/** Where to log — console, file, or notify */
	logTarget: "console" | "file" | "notify";
}

export interface CreateExtensionResult {
	extensionPath: string;
	alreadyExisted: boolean;
	template: ExtensionTemplate;
}

// ── Validation ─────────────────────────────────────────────────────────────

const BLOCKED_PATTERNS = [
	/tool_call/i,           // No tool interception
	/session_shutdown/i,    // No shutdown hooks
	/exec\s*\(/,            // No raw exec
	/child_process/i,       // No child process
	/require\s*\(/,         // No require
	/eval\s*\(/,            // No eval
	/Function\s*\(/,        // No Function constructor
	/process\.env/,         // No env access
	/\.exec\(/,             // No pi.exec
];

function validateSafety(code: string): string[] {
	const violations: string[] = [];
	for (const pattern of BLOCKED_PATTERNS) {
		if (pattern.test(code)) {
			violations.push(`Blocked pattern detected: ${pattern.source}`);
		}
	}
	return violations;
}

function validateName(name: string): string | null {
	if (!/^[a-z0-9]+(-[a-z0-9]+)*$/.test(name)) {
		return `Extension name must be kebab-case: "${name}"`;
	}
	if (name.length > 64) {
		return `Extension name exceeds 64 chars`;
	}
	return null;
}

// ── Templates ──────────────────────────────────────────────────────────────

function generateToolExtension(name: string, description: string, config: ToolConfig): string {
	const params = config.parameters.map(p => {
		const typeMap = { string: "Type.String", number: "Type.Number", boolean: "Type.Boolean" };
		const typeStr = typeMap[p.type] || "Type.String";
		const safeDesc = p.description.replace(/"/g, '\\"');
		const wrapper = p.required === false ? `Type.Optional(${typeStr}({ description: "${safeDesc}" }))` : `${typeStr}({ description: "${safeDesc}" })`;
		return `      ${p.name}: ${wrapper},`;
	}).join("\n");

	const safeToolDesc = config.toolDescription.replace(/"/g, '\\"').replace(/\n/g, " ");
	const safeExecLogic = config.executeLogic.replace(/\n/g, " ").replace(/\*\//g, "* /");
	const safeToolName = config.toolName.replace(/"/g, "");
	const safeLabel = safeToolName.split("_").map((w: string) => w[0].toUpperCase() + w.slice(1)).join(" ");

	return `// AUTO-GENERATED by cortex — review before trusting
// ${description.replace(/`/g, "'").replace(/\n/g, " ")}
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";
import { Type } from "@sinclair/typebox";

export default function (pi: ExtensionAPI) {
  pi.registerTool({
    name: "${safeToolName}",
    label: "${safeLabel}",
    description: "${safeToolDesc}",
    parameters: Type.Object({
${params}
    }),
    async execute(_toolCallId, params, _signal, _onUpdate, _ctx) {
      try {
        // ${safeExecLogic}
        return {
          content: [{ type: "text" as const, text: "TODO: implement ${safeToolName}" }],
          details: {},
        };
      } catch (e) {
        return {
          content: [{ type: "text" as const, text: \`Error: \${(e as Error).message}\` }],
          details: {},
        };
      }
    },
  });

  console.log("[auto-${name}] Extension loaded");
}
`;
}

function generateContextInjector(name: string, description: string, config: ContextInjectorConfig): string {
	// Escape backticks and template literal expressions in content
	const safeContent = config.contextContent.replace(/`/g, "\\`").replace(/\$\{/g, "\\${");
	return `// AUTO-GENERATED by cortex — review before trusting
// ${description.replace(/`/g, "'").replace(/\n/g, " ")}
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  pi.on("before_agent_start", async (event, _ctx) => {
    ${config.condition ? `// Condition: ${config.condition.replace(/`/g, "'").replace(/\n/g, " ")}` : "// Always inject"}
    const context = \`
## ${name.split("-").map((w: string) => w[0].toUpperCase() + w.slice(1)).join(" ")} Context

${safeContent}
\`;

    return {
      systemPrompt: event.systemPrompt + context,
    };
  });

  console.log("[auto-${name}] Extension loaded");
}
`;
}

function generateCommand(name: string, description: string, config: CommandConfig): string {
	const safeCmdDesc = config.commandDescription.replace(/"/g, '\\"').replace(/\n/g, " ");
	const safeCmdName = config.commandName.replace(/"/g, "");
	const safeLogic = config.handlerLogic.replace(/\n/g, " ").replace(/\*\//g, "* /");
	return `// AUTO-GENERATED by cortex — review before trusting
// ${description.replace(/`/g, "'").replace(/\n/g, " ")}
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
  pi.registerCommand("${safeCmdName}", {
    description: "${safeCmdDesc}",
    handler: async (args, ctx) => {
      try {
        // ${safeLogic}
        ctx.ui.notify("${safeCmdName}: TODO implement", "info");
      } catch (e) {
        ctx.ui.notify(\`Error: \${(e as Error).message}\`, "error");
      }
    },
  });

  console.log("[auto-${name}] Extension loaded");
}
`;
}

function generateEventLogger(name: string, description: string, config: EventLoggerConfig): string {
	const handlers = config.events.map(eventName => {
		if (config.logTarget === "notify") {
			return `  pi.on("${eventName}", async (event, ctx) => {
    ctx.ui.notify(\`[${eventName}] \${JSON.stringify(event).slice(0, 100)}\`, "info");
  });`;
		}
		return `  pi.on("${eventName}", async (event, _ctx) => {
    console.log(\`[auto-${name}] ${eventName}:\`, JSON.stringify(event).slice(0, 200));
  });`;
	}).join("\n\n");

	return `// AUTO-GENERATED by cortex — review before trusting
// ${description.replace(/`/g, "'").replace(/\n/g, " ")}
import type { ExtensionAPI } from "@mariozechner/pi-coding-agent";

export default function (pi: ExtensionAPI) {
${handlers}

  console.log("[auto-${name}] Extension loaded");
}
`;
}

// ── Public API ─────────────────────────────────────────────────────────────

/**
 * Create an extension from a template.
 * Validates safety, writes to ~/.pi/agent/extensions/auto-<name>.ts
 */
export async function createExtension(params: CreateExtensionParams): Promise<CreateExtensionResult> {
	const { name, template, description, config } = params;

	// Validate name
	const nameError = validateName(name);
	if (nameError) throw new Error(nameError);

	// Generate code from template
	let code: string;
	switch (template) {
		case "tool":
			code = generateToolExtension(name, description, config as ToolConfig);
			break;
		case "context-injector":
			code = generateContextInjector(name, description, config as ContextInjectorConfig);
			break;
		case "command":
			code = generateCommand(name, description, config as CommandConfig);
			break;
		case "event-logger":
			code = generateEventLogger(name, description, config as EventLoggerConfig);
			break;
		default:
			throw new Error(`Unknown template: ${template}. Available: tool, context-injector, command, event-logger`);
	}

	// Safety validation
	const violations = validateSafety(code);
	if (violations.length > 0) {
		throw new Error(`Safety violation in generated code:\n${violations.join("\n")}`);
	}

	// Ensure directory exists
	if (!existsSync(EXTENSIONS_DIR)) {
		await mkdir(EXTENSIONS_DIR, { recursive: true });
	}

	// Write extension
	const extensionPath = join(EXTENSIONS_DIR, `auto-${name}.ts`);
	const alreadyExisted = existsSync(extensionPath);
	await writeFile(extensionPath, code);

	return { extensionPath, alreadyExisted, template };
}

/**
 * List available templates with descriptions.
 */
export function listTemplates(): Array<{ name: ExtensionTemplate; description: string }> {
	return [
		{ name: "tool", description: "Register a custom LLM-callable tool with parameters" },
		{ name: "context-injector", description: "Inject custom context into system prompt on every turn" },
		{ name: "command", description: "Register a /slash command for interactive use" },
		{ name: "event-logger", description: "Log specific lifecycle events for debugging" },
	];
}
